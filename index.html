<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Three.js Fulcrum Slider Demo</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    /* Slider UI style */
    #fulcrum-slider {
      position: fixed;
      left: 24px;
      top: 50%;
      transform: translateY(-50%) rotate(-90deg);
      width: 200px;
      z-index: 10;
    }
    /* Icon container */
    #icon-container {
      position: fixed;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      z-index: 11;
    }
    .icon-btn {
      width: 0;
      height: 0;
      border-left: 22px solid transparent;
      border-right: 22px solid transparent;
      cursor: pointer;
    }
    .icon-up {
      border-bottom: 30px solid #333;
    }
    .icon-down {
      border-top: 30px solid #333;
    }
    .icon-btn:hover {
      opacity: 0.7;
    }
    /* Reset view button style */
    #reset-view {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 0;
      height: 0;
      border-top: 20px solid transparent;
      border-bottom: 20px solid transparent;
      border-left: 30px solid #333; /* â–¶ arrow shape */
      cursor: pointer;
      z-index: 12;
      transition: transform 0.3s ease; /* smooth rotation */
    }
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
  <!-- Icons stacked vertically -->
  <div id="icon-container">
    <div id="hide-top" class="icon-btn icon-up"></div>
    <div id="hide-bottom" class="icon-btn icon-down"></div>
  </div>

  <!-- Slider -->
  <input id="fulcrum-slider" type="range" min="0" max="2" step="0.01" value="0" />

  <!-- Add this button just before your closing </body> tag -->
  <div id="reset-view" title="Cycle View"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.169.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.169.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

// =======================
// Scene, Camera, Renderer
// =======================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xeeeeee);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  2000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.physicallyCorrectLights = true;
document.body.appendChild(renderer.domElement);

// =======================
// Lighting
// =======================
const hemiLight = new THREE.HemisphereLight(0xffffff, 0x8888aa, 1.0);
scene.add(hemiLight);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
dirLight.position.set(10, 20, 10);
dirLight.castShadow = true;
dirLight.shadow.bias = -0.001;
scene.add(dirLight);

const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.7);
fillLight1.position.set(-15, 8, 5);
scene.add(fillLight1);

const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.7);
fillLight2.position.set(15, 5, -8);
scene.add(fillLight2);

const rectLight = new THREE.RectAreaLight(0xffffff, 8.0, 15, 15);
rectLight.position.set(0, -10, 0);
rectLight.rotation.x = Math.PI / 2;
scene.add(rectLight);

const underLight = new THREE.SpotLight(0xffffff, 2.0, 50, Math.PI / 3, 0.4);
underLight.position.set(0, -12 * 1.1, 0);
underLight.target.position.set(0, 0, 0);
scene.add(underLight);
scene.add(underLight.target);

const gapLight = new THREE.PointLight(0xffffff, 2.5, 10);
gapLight.position.set(0, 0, 0);
scene.add(gapLight);

// =======================
// Controls
// =======================
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

// =======================
// Model Variables
// =======================
let fulcrum, topComponent;
let fulcrumInitialY = 0;
const maxSeparation = 2;

// =======================
// Load GLTF Model
// =======================
const loader = new GLTFLoader();
loader.load(
  "./MBC.glb",
  function (gltf) {
    const model = gltf.scene;
    
    fulcrum = model.getObjectByName("Small_Fulrum999990000");
    topComponent = model.getObjectByName("Component1900top");

    scene.add(model);

    const box = new THREE.Box3().setFromObject(model);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    model.position.sub(center);

    const maxDim = Math.max(size.x, size.y, size.z);
    const scale = 10 / maxDim;
    model.scale.set(scale, scale, scale);

    const scaledBox = new THREE.Box3().setFromObject(model);
    const scaledSize = scaledBox.getSize(new THREE.Vector3());
    const scaledCenter = scaledBox.getCenter(new THREE.Vector3());
    const fov = camera.fov * (Math.PI / 180);
    let cameraZ = Math.abs(Math.max(scaledSize.x, scaledSize.y, scaledSize.z) / 2 / Math.tan(fov / 2));
    cameraZ *= 1.2;
    camera.position.set(0, scaledSize.y * 0.5, cameraZ);
    controls.target.copy(scaledCenter);
    controls.update();

    fulcrumInitialY = fulcrum.position.y;

    const topBox = new THREE.Box3().setFromObject(topComponent);
    const fulcrumBox = new THREE.Box3().setFromObject(fulcrum);
    const fullRange = fulcrum.position.y - topBox.min.y - (fulcrumBox.max.y - fulcrumBox.min.y);
    const limitedRange = fullRange * 0.09;

    const slider = document.getElementById('fulcrum-slider');
    slider.min = 0;
    slider.max = 1;
    slider.step = 0.001;
    slider.value = 1;

    slider.oninput = function () {
      const t = parseFloat(slider.value);
      fulcrum.position.y = fulcrumInitialY + limitedRange * (1 - t);
    };

    slider.oninput();

    // ==========
    // ICON EVENTS
    // ==========
    document.getElementById("hide-top").onclick = () => {
      if (topComponent) topComponent.visible = !topComponent.visible;
    };
    document.getElementById("hide-bottom").onclick = () => {
      if (fulcrum) fulcrum.visible = !fulcrum.visible;
    };

    // ==========
    // RESET VIEW EVENT
    // ==========
    document.getElementById("reset-view").onclick = () => {
      camera.position.set(0, scaledSize.y * 0.5, cameraZ);
      controls.target.copy(scaledCenter);
      controls.update();
    };

    // =========
    // RESET VIEW CYCLER
    // =========
    let viewIndex = 0;
    const views = ["front", "side", "top", "back"];
    const resetBtn = document.getElementById("reset-view");

    resetBtn.onclick = () => {
      if (!fulcrum || !topComponent) return;

      const box = new THREE.Box3().setFromObject(scene);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      // Step to the next view
      viewIndex = (viewIndex + 1) % views.length;
      const view = views[viewIndex];

      switch (view) {
        case "front": // +Z
          camera.position.set(center.x, center.y, size.z * 1.5);
          resetBtn.style.transform = "rotate(0deg)";
          break;
        case "side": // +X
          camera.position.set(size.x * 1.5, center.y, center.z);
          resetBtn.style.transform = "rotate(90deg)";
          break;
        case "top": // +Y
          camera.position.set(center.x, size.y * 9, center.z); // zoomed out more
          resetBtn.style.transform = "rotate(180deg)";
          break;
        case "back": // -Z
          camera.position.set(center.x, center.y, -size.z * 1.5);
          resetBtn.style.transform = "rotate(-90deg)";
          break;
      }

      controls.target.copy(center);
      controls.update();
    };

    animate();
  },
  undefined,
  function (error) {
    console.error("Error loading model:", error);
  }
);

// =======================
// Responsive Resize
// =======================
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// =======================
// Animation Loop
// =======================
function animate() {
  requestAnimationFrame(animate);
  controls.update();

  if (fulcrum && topComponent) {
    const topY = topComponent.position.y;
    const fulcrumY = fulcrum.position.y;
    gapLight.position.y = (topY + fulcrumY) / 2;
    gapLight.position.x = 0;
    gapLight.position.z = 0;
  }

  renderer.render(scene, camera);
}
</script>
</body>
</html>
